//
//  DeeplyCopyable.swift
//  Probing
//
//  Created by Kamil Strzelecki on 22/01/2025.
//  Copyright Â© 2025 Kamil Strzelecki. All rights reserved.
//

/// Defines and implements conformance to the ``DeeplyCopyable-protocol`` protocol for final classes, structs and enums.
///
/// - Important: If any stored property or associated value of the type is not ``DeeplyCopyable-protocol``, the code generated by the macro
/// will fail to compile. To resolve this, either apply the macro directly to the types used as stored properties or associated values, or manually declare
/// their conformance if they come from a third-party module.
///
@attached(
    member,
    names: named(init(deeplyCopying:))
)
@attached(
    extension,
    conformances: DeeplyCopyable,
    names: named(init(deeplyCopying:))
)
public macro DeeplyCopyable() = #externalMacro(
    module: "DeeplyCopyableMacros",
    type: "DeeplyCopyableMacro"
)

/// A type whose instances can be copied without sharing underlying storage, while remaining otherwise value-equal.
///
/// A deep copy of an instance, created via ``init(deeplyCopying:)``, will ultimately not share any direct on indirect references
/// with the original instance. As a result, mutations to one instance will never affect the other.
///
/// - Note: For types that use copy-on-write mechanism, underlying storage may be shared until the first mutation.
/// This implementation detail does not affect any of the guarantees provided by `DeeplyCopyable` protocol.
///
public protocol DeeplyCopyable: Copyable {

    /// Creates a new instance that is value-equal to `other`, but shares no underlying storage.
    ///
    /// - Parameter other: The instance to deep copy.
    ///
    init(deeplyCopying other: Self)
}

extension DeeplyCopyable {

    /// Creates a new instance that is value-equal to this instance, but shares no underlying storage.
    ///
    /// - Returns: A deep copy of this instance.
    ///
    public func deepCopy() -> Self {
        .init(deeplyCopying: self)
    }
}
